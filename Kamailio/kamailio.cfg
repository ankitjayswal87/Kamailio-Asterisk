#!KAMAILIO
#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_ACCDB
#!define WITH_IPAUTH
#!define WITH_ASTERISK
#!define WITH_TLS
#!define WITH_NAT
#!define WITH_WEBSOCKETS
#!define WITH_PSTN

#!substdef "!MY_WS_PORT!8080!g"
#!substdef "!MY_WSS_PORT!8089!g"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
#!ifndef DBURL
#!define DBURL "mysql://admin:8FRf4T@localhost/kamailio"
#!define DBURL_REGISTRATION "mysql://remoteadminkamailio:8FRf4T@10.122.0.3/asterisk"
#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define FLB_RTPWS 8
#!define FLB_IPV6 9
#!define FLB_V4V6 10
#!define FLB_BRIDGE 11

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
#ANKIT JAYSWAL
#disable_tcp=yes
tcp_connection_lifetime=3604
tcp_accept_no_cl=yes
#tcp_reuse_port = no
#25Feb
tcp_rd_buf_size=16384
enable_tls=yes
/* number of SIP routing processes for all TCP/TLS sockets */
# tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

#ANKIT JAYSWAL
#listen=udp:10.122.0.2:5090 advertise "167.71.235.234":5090
#listen=tcp:10.122.0.2:5091 advertise "167.71.235.234":5091
#listen=tls:10.122.0.2:8089 advertise "167.71.235.234":8089

listen=udp:10.122.0.2:5090
listen=tcp:10.122.0.2:5091
listen=tls:10.122.0.2:8089

listen=udp:167.71.235.234:5090
listen=tcp:167.71.235.234:5091
listen=tls:167.71.235.234:8089
/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

####### Custom Parameters #########
asterisk.bindip = "10.122.0.4" desc "Asterisk IP Address"
asterisk.bindport = "5080" desc "Asterisk Port"
kamailio.bindip = "10.122.0.2" desc "Kamailio IP Address"
kamailio.bindport = "5090" desc "Kamailio Port"

#!ifdef WITH_PSTN
pstn.gw_ip = "kamailioazure.pstn.twilio.com" desc "Twilio SIP Trunk"
pstn.gw_port = "" desc "Twilio GW Port"
#!endif

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#ANKIT JAYSWAL
#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "tls.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "dialog.so"
loadmodule "counters.so"
loadmodule "dispatcher.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
#loadmodule "nat_traversal.so"

loadmodule "uac.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
#loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
#ANKIT JAYSWAL
modparam("dispatcher", "db_url", DBURL)                 #Use DBURL variable for database parameters
modparam("dispatcher", "ds_ping_interval", 10)          #How often to ping destinations to check status
modparam("dispatcher", "ds_ping_method", "OPTIONS")     #Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 10)      #How many failed pings in a row do we need before we consider it down
modparam("dispatcher", "ds_inactive_threshold", 10)     #How many sucessful pings in a row do we need before considering it up
modparam("dispatcher", "ds_ping_latency_stats", 1)      #Enables stats on latency
modparam("dispatcher", "ds_probing_mode", 1)
modparam("jsonrpcs", "pretty_format", 1)

# ----- sanity params -----
modparam("sanity", "autodrop", 0)

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
#modparam("rr", "enable_full_lr", 0)
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
#modparam("rr", "append_fromtag", 0)

#!ifdef WITH_ASTERISK
modparam("rr", "append_fromtag", 1)
#!else
modparam("rr", "append_fromtag", 0)
#!endif

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU */
modparam("registrar", "gruu_enabled", 0)

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
#DIALOG MODULE NEEDS TO BE LOADED AND SET PARAMETERS TO USE ACC MODULE
#ANKIT JAYSWAL
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 1)

modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "db_table_acc", "acc")
modparam("acc", "cdrs_table", "acc_cdrs")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "acc_method_column", "method")
modparam("acc", "acc_from_tag_column", "from_tag")
modparam("acc", "acc_to_tag_column", "to_tag")
modparam("acc", "acc_callid_column", "callid")
modparam("acc", "acc_sip_code_column", "sip_code")
modparam("acc", "acc_sip_reason_column", "sip_reason")
modparam("acc", "acc_time_column", "time")
modparam("acc", "db_extra","src_user=$fU;src_domain=$fd;src_ip=$si;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
#ANKIT JAYSWAL
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
#ANKIT JAYSWAL
modparam("auth_db", "db_url", DBURL_REGISTRATION)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
#ANKIT JAYSWAL
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "load_backends", 1)
modparam("permissions", "address_table", "address")
modparam("permissions", "grp_col", "grp")
modparam("permissions", "ip_addr_col", "ip_addr")
modparam("permissions", "mask_col", "mask")
modparam("permissions", "port_col", "port")
#!endif

#!endif

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
/* register callback to match myself condition with domains list */
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
# ----- rtpproxy params -----
#modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:7722")
#modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")

# ----- nathelper params -----
#ANKIT JAYSWAL
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
#ANKIT JAYSWAL
modparam("tls", "tls_method", "SSLv23")
#modparam("tls", "tls_method", "TLSv1.2")
modparam("tls", "certificate", "/etc/pki/CA/kamailio1_cert.pem")
modparam("tls", "private_key", "/etc/pki/CA/privkey.pem")
#modparam("tls", "ca_list", "/etc/pki/CA/catlist.pem")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

#ANKIT JAYSWAL
modparam("uac", "reg_db_url","mysql://admin:8FRf4T@localhost/kamailio")
modparam("uac", "reg_contact_addr", "10.122.0.2:5090")
modparam("uac","restore_mode","auto")
####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
	xlog("L_INFO", "SIP MESSAGES:----- $mb\n");
	
	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

	#25Feb
	#!ifdef WITH_WEBSOCKETS
	if (nat_uac_test(64)) {
		# Do NAT traversal stuff for requests from a WebSocket
		# connection - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
		force_rport();
		if (is_method("REGISTER")) {
			xlog("L_INFO", "SIP request received $Rp\n");
			fix_nated_register();
		}
		#else {
			#if (!add_contact_alias()) {
			#xlog("L_ERR", "Error aliasing contact <$ct>\n");
				#sl_send_reply("400", "Bad Request");
				#exit;
			#}
		#}
	}
	#!endif

	#ANKIT JAYSWAL
	#if(!allow_source_address("1")){
	#	xlog("L_ALERT", "INSIDE FROM ALLOW IP AND PORT.....\n");
	#	sl_send_reply("484","IP Address Not Allowed");
        #        exit;
	#}

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}


	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	#if (is_method("ACK")) {
	     #xlog("L_INFO", "***********value of duri is $duri and ruri is $ruri\n");
             #$duri= $ruri;
             #t_relay();
             #exit;
     	#}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)
	#ANKIT JAYSWAL
	if(method=="INVITE"){
		if(!lookup("location")){
			xlog("L_ALERT", "FROM DOMAIN COMING FROM---------------- $fd\n");
			#xlog("L_ALERT", "time [$Tf] method ($rm) r-uri ($ru) 2nd via ($hdr(via[1]))\n");
			#xlog("L_ALERT", "Normal Dispatch Call From Domain: $fd and from user $rU\n");
			record_route();
			#record_route_preset("49.14.116.12:41050");
			setflag(FLT_ACC);
			setflag(FLT_ACCFAILED);
			setflag(FLT_ACCMISSED);
			if($fd=="10.122.0.3"||$fd=="10.122.0.4"||$fd=="167.71.231.118"||$fd=="157.245.104.168"){
				xlog("L_ALERT", "OUTGOING CALL FROM DOMAIN IS $fd\n");
				$fU="+19194325232";
				$fd="kamailioazure.pstn.twilio.com";
				#uac_replace_from("19194325232","");
				route(PSTN);
			}
			else{
                	ds_select_dst(1, 4);    #Get a destination in round robin fashion from dispatcher
			#t_on_failure("DISPATCH_FAILURE");
                	route(RELAY);
			}    
            	}
		else{
			xlog("L_ALERT", "Dial SIP USER\n");
			#if (client_nat_test("3")) {
				#xlog("L_ALERT", "INSIDE FIXING CONTACT......\n");
				#fix_contact();
			#}
			#reg_fetch_contacts("location", "$ru", "callee");
			#xlog("L_ALERT", "PROFILE: ($ulc(profile))");
			record_route();
			#record_route_preset("$si:$sp");
			#lookup("location");
                        t_relay();
			#route(RELAY);
			exit();
		}
        }
	#ANKIT JAYSWAL
	if(method=="REGISTER"){
		xlog("L_ALERT", "REGISTER REQUEST COMING...\n");
		if(!auth_check("$fd", "ps_auths", "1")){
		#if(!auth_check("$fd", "subscriber", "1")){
			xlog("L_ALERT", "User NOT Authenticated\n");
			auth_challenge("$fd", "0");
			exit;
		}
		else{
			xlog("L_ALERT", "User Authenticated\n");
                	save("location");
			xlog("L_ALERT", "LOCATION SAVED...\n");
			route(REGFWD);
			#ds_select_dst(1, 4);
			#route(RELAY);
                	exit;
		}
        }

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

	### requests for my local domains

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

}

# Wrapper for relaying requests
route[RELAY] {

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
	# no connect for sending replies
	set_reply_no_connect();

#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
	if($ua =~ "friendly-scanner|sipcli|sipvicious|VaxSIPUserAgent") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	xlog("L_ALERT", "INSIDE WITHIN DLG...\n");
	if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		xlog("L_ALERT", "INSIDE LOOSE ROUTE...\n");
		#25Feb
		#!ifdef WITH_WEBSOCKETS
			if ($du == "") {
				if (!handle_ruri_alias()) {
					xlog("L_ERR", "Bad alias <$ru>\n");
					sl_send_reply("400", "Bad Request");
					exit;
				}
			}
		#!endif
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
			# ACK is forwarded statelessly
			xlog("L_ALERT", "INSIDE METHOD ACK...\n");
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		#route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		xlog("L_ALERT", "INSIDE METHOD ACK2...\n");
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			xlog("L_ALERT", "ACK without matching transaction...\n");
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
			if (check_route_param("rtp=bridge")) {
				setbflag(FLB_BRIDGE);
			}

			if (check_route_param("rtp=ws")) {
				setbflag(FLB_RTPWS);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

	if (!isbflagset(FLB_BRIDGE)) {
		return;
	}

	if (
		!(isflagset(FLT_NATS)
		|| isbflagset(FLB_NATB)
		|| isbflagset(FLB_RTPWS)
#!ifdef WITH_IPV6
		|| isbflagset(FLB_V4V6)
#!endif
	)) {
		return;
	}

	#if(nat_uac_test("8")) {
		#rtpproxy_manage("co");
	#} else {
		#rtpproxy_manage("cor");
	#}

	$xavp(r=>$T_branch_idx) = "replace-origin replace-session-connection";

	if (!nat_uac_test("8")) {
		$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " trust-address";
	}


	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
			if (!t_is_failure_route()) {
				$avp(extra_id) = @via[1].branch + $T_branch_idx;
				$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " via-branch=extra";
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
		$avp(extra_id) = @via[2].branch + $T_branch_idx;
		$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " via-branch=extra";
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
	# allow XMLRPC from localhost
	if ((method=="POST" || method=="GET")
			&& (src_ip==127.0.0.1)) {
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}
	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	#t_on_branch_failure("rtpengine");
#!ifndef WITH_BRIDGE_ON_FAIL
	setbflag(FLB_BRIDGE);
#!endif
	route(BRIDGING);
	route(NATMANAGE);
}

# Manage incoming replies
reply_route {
	if(!sanity_check("17604", "6")) {
		xlog("Malformed SIP response from $si:$sp\n");
		drop;
	}
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

}

#ANKIT JAYSWAL
#25Feb
#!ifdef WITH_WEBSOCKETS
onreply_route {
	if ((($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT) && !(proto == WS || proto == WSS))) {
		xlog("L_WARN", "SIP response received on $Rp\n");
		drop;
	}

	if (nat_uac_test(64)) {
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
		add_contact_alias();
	}
}

event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();
	
	if ($Rp != MY_WS_PORT
#!ifdef WITH_TLS
	    && $Rp != MY_WSS_PORT
#!endif
	) {
		xlog("L_WARN", "HTTP request received on $Rp\n");
		xhttp_reply("403", "Forbidden", "", "");
		exit;
	}

	xlog("L_DBG", "HTTP Request Received\n");

	if ($hdr(Upgrade)=~"websocket"
			&& $hdr(Connection)=~"Upgrade"
			&& $rm=~"GET") {

		# Validate Host - make sure the client is using the correct
		# alias for WebSockets
		if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
			xlog("L_WARN", "Bad host $hdr(Host)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}

		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake())
		{
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}

	xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
	xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
#!endif



route[BRIDGING] {
	if (!has_totag()) {
		if ($proto =~ "ws" && !($ru =~ "transport=ws")) { # Coming from WS, NOT to WS
			setbflag(FLB_RTPWS); # Need bridging
		} else if (!($proto =~ "ws") && $ru =~ "transport=ws") { # Coming from NOT WS, going to WS
			setbflag(FLB_RTPWS); # Need bridging
		}

#!ifdef WITH_IPV6
		if (af == INET6 && !isbflagset(FLB_IPV6)) {
			setbflag(FLB_V4V6);
		} else if(af == INET && isbflagset(FLB_IPV6)) {
			setbflag(FLB_V4V6);
		}
#!endif
	}
}


route[REGFWD] {
	xlog("L_INFO", "inside registration forward $fd\n");
	if(!is_method("REGISTER"))
	{
		return;
	}
	$var(rip) = $sel(cfg_get.asterisk.bindip);
	xlog("L_INFO", "value of rip is $var(rip)\n");
	$uac_req(method)="REGISTER";
	$uac_req(ruri)="sip:" + $var(rip) + ":" + $sel(cfg_get.asterisk.bindport);
	$uac_req(furi)="sip:" + $au + "@" + $var(rip);
	$uac_req(turi)="sip:" + $au + "@" + $var(rip);
	$uac_req(hdrs)="Contact: <sip:" + $au + "@"
				+ $sel(cfg_get.kamailio.bindip)
				+ ":" + $sel(cfg_get.kamailio.bindport) + ">\r\n";
	if($sel(contact.expires) != $null)
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $sel(contact.expires) + "\r\n";
	else
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $hdr(Expires) + "\r\n";
	xlog("L_INFO", "sending request to asterisk $uac_req(hdrs)\n");
	uac_req_send();

}


route[PSTN] {
#!ifdef WITH_PSTN
	xlog("L_INFO", "**********Inside PSTN route \n");
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) {
		xlog("SCRIPT: PSTN routing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	if(!($rU=~"^(\+|00|91)[1-9][0-9]{3,20}$")) return;

	# only local users allowed to call
	#if(from_uri!=myself) {
	#	sl_send_reply("403", "Not Allowed");
	#	exit;
	#}

	# normalize target number for pstn gateway
	# - convert leading 00 to +
	if (starts_with("$rU", "91")) {
		prefix("+");
	}

	if (strempty($sel(cfg_get.pstn.gw_port))) {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	} else {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}
	xlog("SETTING RU --------------- $ru\n");
	route(RELAY);
	exit;
#!endif
	xlog("L_INFO", "***********Reurning from PSTN route\n");
	return;
}
